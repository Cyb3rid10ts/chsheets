### TRIGGERS ### ****************************************************

  # Pull strategy
    * Reaches out to see if changes in the code
  # Push strategy
    * Something else notifies Jenkins the code changed 

#Triggers can be implemented in three ways
  # General Configuration of the Project

  # Scripted Pipeline
    # Example: Building a Project
    # after other projects are built
    properties([
      pipelineTriggers([
        upstream(
          threshold: hudson.model.Result.SUCCESS,
          upstreamProjects: 'Job1'
        )
      ])
    ])

    # Example: Build periodically
    properties([pipelineTriggers([cron('0 9 * * 1-5')])])

    # Example: Github Hook Trigger for GitSCM polling
    # Used to trigger a build when git push initiated
    properties([pipelineTriggers([githubPush()])])

    # Example: Poll SCM periodically
    properties([pipelineTriggers([pollSCM('*/30 * * * *')])])

  # Declarative Pipeline

    # Example: Build periodically
    triggers { cron(0 9 * * 1-5) 

    # Example: Poll SCM periodically
    triggers { pollSCM(*/30 * * * *) }

    # Example: Trigger builds remotely by 
    # accessing a specific URL for the given
    # job on the Jenkins system

  # Freestyle project
    # Check "Github hook trigger for GITScm polling"
    # Global config should have auth configured
    # Under the settings of the repo, the webhook
    # will show up once the project is created

### USER INPUT ### ****************************************************

# Prompt user with message
input 'Continue with the final stage?'

# Give the user a variety of choices
def choice = input message: '<message>', 
 parameters: [choice(choices: "choice1\nchoice2\nchoice3\nchoice4\n",
 description: 'Choose one of the following options', name: 'Options')]

# Boolean
def answer = input message: '<message>', 
 parameters: [booleanParam(defaultValue: true, 
 description: 'Prerelease setting', name: 'prerelease')]

# Choosing a file to use with the pipeline
def selectedFile = input message: '<message>', 
 parameters: [file(description: 'Choose file to upload', name: 'local')]

# Multiline string
def lines = input message: '<message>', 
 parameters: [text(defaultValue: '''line 1
 line 2
 line 3''', description: '', name: 'Input Lines')]

 # Script block (Used for allowing scripted pipeline syntax
 # in declarative syntax language)
  stage ('Input') {
           steps {  
              script {
                 def resp = input message: '<message>', 
                  parameters: [string(defaultValue: '',
                  description: 'Enter response 1',
                  name: 'RESPONSE1'), string(defaultValue: '',
                  description: 'Enter response 2', name: 'RESPONSE2')]
                 echo "${resp.RESPONSE1}"
              }
              echo "${resp.RESPONSE2}"
           }
}

## Flow control options ##

# Use timeout (Limits amount of time your script spends waiting
# for an action to happen)
node {
    def response
    stage('input') {
       timeout(time:10, unit:'SECONDS') {
          response = input message: 'User', 
           parameters: [string(defaultValue: 'user1', 
           description: 'Enter Userid:', name: 'userid')]
       }
       echo "Username = " + response
    }
}

# Exception handling with timeout
node {
    def response
    stage('input') {
       try {
         timeout(time:10, unit:'SECONDS') {
            response = input message: 'User', 
             parameters: [string(defaultValue: 'user1',
             description: 'Enter Userid:', name: 'userid')]
         }
       }
       catch (err) {
          response = 'user1'
       }
    }
}

# Retrying the process
retry(<n>) { // processing }

# Sleeping (Delay step)
sleep time: 5, unit: 'MINUTES'

# Wait until something happens
timeout(time:15, unit:'SECONDS') {
    waitUntil {
       def ret = sh returnStatus: true, 
         script: 'test -e /home/jenkins2/marker.txt'
       return (ret == 0)
    }

 }

# Stash and unstash
# Allows for saving and retreving files between
# nodes and/or stages in a pipeline

stages {
   
   stage('Source') {
      git branch: 'test', url: 'git@diyv:repos/gradle-greetings'
      stash name: 'test-source', includes: 'build.gradle,src/test/'
   }
  ...
   stage ('Test') {
   // execute required unit tests in parallel

      parallel (
         master: { node ('master') {
            unstash 'test-sources'
            sh '/opt/gradle-2.7/bin/gradle -D test.single=TestExample1 test'
         }},
         worker2: { node ('worker_node2') {
            unstash 'test-sources'
            sh '/opt/gradle-2.7/bin/gradle -D test.single=TestExample2 test'
         }},
      )
   }
}

# Advanced error handling
def err = null
try {
   // pipeline code
   node ('node-name') {
      stage ('first stage') {
         ...
      } // end of last stage
   }
} 
catch (err) { 
   currentBuild.result = "FAILURE"
} 
finally {
   (currentBuild.result != "ABORTED"){
       // Send email notifications for builds that failed 
       //  or are unstable
   }
}

# Post-processing
# Conditions:
    # always: Always executes the steps in the block
    # changed: Executed if current build different from previous build
    # success: Executes if current build successful
    # failure: Executes if current build failed
    # unstable: Executes if current build unstable

      }
    } // end stages
    post {
       always {
          echo "Build stage complete"
       }
       failure {
          echo "Build failed"
          mail body: 'build failed', subject: 'Build failed!',
             to: 'devops@company.com'
        }
        success {
          echo "Build succeeded"
          mail body: 'build succeeded', subject: 'Build Succeeded',
             to: 'devops@company.com'
        }
    }
} // end pipeline

# Sending an email
pipeline {
  agent any
  stages {
   ...
  }
  post {
    always {
       mail to: 'blob@gmail.org',
          subject: "Status of pipeline: ${currentBuild.fullDisplayName}",
          body: "${env.BUILD_URL} has result ${currentBuild.result}"
    }
  }
}
  # SMTP server, default user email suffix, SMTP
  # authentication defined in global settings

# Send email with attached logs
  emailext attachLog: true, body:
   """<p>EXECUTED: Job <b>\'${env.JOB_NAME}:${env.BUILD_NUMBER})\'
   </b></p><p>View console output at "<a href="${env.BUILD_URL}"> 
   ${env.JOB_NAME}:${env.BUILD_NUMBER}</a>"</p> 
     <p><i>(Build log is attached.)</i></p>""", 
    compressLog: true,
    recipientProviders: [[$class: 'DevelopersRecipientProvider'], 
     [$class: 'RequesterRecipientProvider']],
    replyTo: 'do-not-reply@company.com', 
    subject: "Status: ${currentBuild.result?:'SUCCESS'} - 
    Job \'${env.JOB_NAME}:${env.BUILD_NUMBER}\'", 
    to: 'bcl@nclasters.org Brent.Laster@domain.com'